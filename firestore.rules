rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Group membership helper
    function isGroupMember(groupId) {
      return isSignedIn() && exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid));
    }

    // Utility helpers
    function isSignedIn() { return request.auth != null; }
    function isOwner(uid) { return isSignedIn() && request.auth.uid == uid; }
    function isPolice() {
      return isSignedIn() && (
        request.auth.token.role == 'police' ||
        (request.auth.token.roles is list && 'police' in request.auth.token.roles)
      );
    }

    // 1) Make ALL READS public so the dashboard can always fetch alerts.
    match /{document=**} {
      allow read: if true;

      // Police can write absolutely anywhere
      allow write: if isPolice();
    }

    // 2) Minimal WRITE permissions for users under /users/{uid}
    match /users/{uid} {
      allow create, update: if isOwner(uid);
      allow delete: if false;

      match /alerts/{state}/items/{alertId} {
        // Owners can create alerts in active or past
        allow create: if isOwner(uid) && (state == 'active' || state == 'past');

        // Owners can update only active alerts to set resolvedAt
        allow update: if isOwner(uid) && state == 'active' &&
                      resource.data.resolvedAt == null &&
                      request.resource.data.resolvedAt is timestamp;

        // Owners can delete only their active alerts
        allow delete: if isOwner(uid) && state == 'active';
      }
    }

    // 3) Groups feature
    match /groups/{groupId} {
      // Anyone signed-in can read group metadata; writes are constrained below
      allow read: if isSignedIn();

      // Create group: only signed-in users; ownerUid must match caller
      allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;

      // Update: only owner can update top-level group metadata
      allow update: if isSignedIn() && resource.data.ownerUid == request.auth.uid;

      // Delete: only owner
      allow delete: if isSignedIn() && resource.data.ownerUid == request.auth.uid;

      // Members subcollection
      match /members/{memberUid} {
        // Read members if you are a member
        allow read: if isGroupMember(groupId);

        // Join: allow creating your own member doc
        allow create: if isSignedIn() && memberUid == request.auth.uid;

        // Update: allow members to update their own member doc (e.g., display name)
        allow update: if isSignedIn() && memberUid == request.auth.uid;

        // Leave: allow deleting your own member doc; owner can remove anyone
        allow delete: if (isSignedIn() && memberUid == request.auth.uid) ||
                       (isSignedIn() && exists(/databases/$(database)/documents/groups/$(groupId)) &&
                        get(/databases/$(database)/documents/groups/$(groupId)).data.ownerUid == request.auth.uid);
      }

      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isGroupMember(groupId);
        // Sender must be the caller
        allow create: if isGroupMember(groupId) && request.resource.data.senderUid == request.auth.uid;
        // No updates/deletes to messages for simplicity
        allow update, delete: if false;
      }

      // Alerts subcollection (group-wide alerts mirrored from member alerts)
      match /alerts/{alertId} {
        allow read: if isGroupMember(groupId);
        // Any member can create an alert for the group
        allow create: if isGroupMember(groupId) && request.resource.data.triggeredBy == request.auth.uid;
        // Allow updates to resolve alerts by any member or owner
        allow update: if isGroupMember(groupId);
        allow delete: if false;
      }
    }

    // 4) Users' group index for efficient listing: users/{uid}/groups/{groupId}
    match /users/{uid}/groups/{groupId} {
      allow read, create, update, delete: if isOwner(uid);
    }
  }
}
