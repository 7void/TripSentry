import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';

class GroupService {
  GroupService._();
  static final GroupService instance = GroupService._();

  final FirebaseFirestore _fs = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  String? get _uid => _auth.currentUser?.uid;

  /// Create a group owned by current user and join it.
  Future<String?> createGroup({
    required String name,
    String? tripId,
    String? description,
  }) async {
    final uid = _uid;
    if (uid == null) return null;
    try {
      final now = FieldValue.serverTimestamp();
      final ref = await _fs.collection('groups').add({
        'name': name,
        'tripId': tripId,
        'description': description,
        'ownerUid': uid,
        'createdAt': now,
        'updatedAt': now,
      });
      // Add membership docs (group->member and user->group index)
      await _fs.collection('groups').doc(ref.id).collection('members').doc(uid).set({
        'joinedAt': now,
        'role': 'owner',
        'name': _auth.currentUser?.displayName ?? (_auth.currentUser?.email?.split('@').first ?? 'Me'),
      });
      await _fs.collection('users').doc(uid).collection('groups').doc(ref.id).set({
        'joinedAt': now,
        'name': name,
      });
      return ref.id;
    } catch (e, st) {
      debugPrint('[GroupService] createGroup error: $e\n$st');
      return null;
    }
  }

  /// Join an existing group by ID.
  Future<bool> joinGroup(String groupId) async {
    final uid = _uid;
    if (uid == null) return false;
    try {
      final groupRef = _fs.collection('groups').doc(groupId);
      final snap = await groupRef.get();
      if (!snap.exists) return false;
      final now = FieldValue.serverTimestamp();
      await groupRef.collection('members').doc(uid).set({
        'joinedAt': now,
        'role': 'member',
        'name': _auth.currentUser?.displayName ?? (_auth.currentUser?.email?.split('@').first ?? 'Member'),
      }, SetOptions(merge: true));
      await _fs.collection('users').doc(uid).collection('groups').doc(groupId).set({
        'joinedAt': now,
        'name': snap.data()?['name'] ?? '',
      }, SetOptions(merge: true));
      return true;
    } catch (e, st) {
      debugPrint('[GroupService] joinGroup error: $e\n$st');
      return false;
    }
  }

  /// Leave a group by ID.
  Future<bool> leaveGroup(String groupId) async {
    final uid = _uid;
    if (uid == null) return false;
    try {
      final batch = _fs.batch();
      final groupRef = _fs.collection('groups').doc(groupId);
      batch.delete(groupRef.collection('members').doc(uid));
      batch.delete(_fs.collection('users').doc(uid).collection('groups').doc(groupId));
      await batch.commit();
      return true;
    } catch (e, st) {
      debugPrint('[GroupService] leaveGroup error: $e\n$st');
      return false;
    }
  }

  /// Stream groups for current user from index collection.
  Stream<List<Map<String, dynamic>>> groupsStream() {
    final uid = _uid;
    if (uid == null) return const Stream<List<Map<String, dynamic>>>.empty();
    return _fs
        .collection('users')
        .doc(uid)
        .collection('groups')
        .orderBy('joinedAt', descending: true)
        .snapshots()
        .map((s) => s.docs.map((d) => {'id': d.id, ...?d.data()}).toList());
  }

  /// Send a text message to a group.
  Future<bool> sendMessage(String groupId, String text) async {
    final uid = _uid;
    if (uid == null || text.trim().isEmpty) return false;
    try {
      await _fs.collection('groups').doc(groupId).collection('messages').add({
        'senderUid': uid,
        'senderName': _auth.currentUser?.displayName ?? (_auth.currentUser?.email?.split('@').first ?? 'Member'),
        'text': text.trim(),
        'createdAt': FieldValue.serverTimestamp(),
      });
      return true;
    } catch (e, st) {
      debugPrint('[GroupService] sendMessage error: $e\n$st');
      return false;
    }
  }

  /// Stream recent messages in a group.
  Stream<List<Map<String, dynamic>>> messagesStream(String groupId, {int limit = 100}) {
    return _fs
        .collection('groups')
        .doc(groupId)
        .collection('messages')
        .orderBy('createdAt', descending: true)
        .limit(limit)
        .snapshots()
        .map((s) => s.docs.map((d) => {'id': d.id, ...?d.data()}).toList().reversed.toList());
  }

  /// Fan-out an alert generated by the current user to all groups they are part of.
  /// type: 'geofencing' | 'emergency' | 'panic'
  Future<void> fanoutAlertToGroups({
    required String type,
    Map<String, dynamic>? location,
    Map<String, dynamic>? extra,
  }) async {
    final uid = _uid;
    if (uid == null) return;
    try {
      final groups = await _fs.collection('users').doc(uid).collection('groups').get();
      if (groups.docs.isEmpty) return;
      final now = FieldValue.serverTimestamp();
      final batch = _fs.batch();
      for (final g in groups.docs) {
        final groupId = g.id;
        final alerts = _fs.collection('groups').doc(groupId).collection('alerts');
        final data = <String, dynamic>{
          'type': type,
          'triggeredAt': now,
          'resolvedAt': null,
          'triggeredBy': uid,
        };
        if (location != null) data['location'] = location;
        if (extra != null && extra.isNotEmpty) data['extra'] = extra;
        batch.set(alerts.doc(), data);
      }
      await batch.commit();
    } catch (e, st) {
      debugPrint('[GroupService] fanoutAlertToGroups error: $e\n$st');
    }
  }

  /// Broadcast a system message to all groups the current user belongs to.
  Future<void> broadcastSystemMessage(String text) async {
    final uid = _uid;
    if (uid == null || text.trim().isEmpty) return;
    try {
      final groups = await _fs.collection('users').doc(uid).collection('groups').get();
      if (groups.docs.isEmpty) return;
      final now = FieldValue.serverTimestamp();
      final senderName = _auth.currentUser?.displayName ?? (_auth.currentUser?.email?.split('@').first ?? 'Member');
      final batch = _fs.batch();
      for (final g in groups.docs) {
        final messages = _fs.collection('groups').doc(g.id).collection('messages').doc();
        batch.set(messages, {
          'senderUid': uid,
          'senderName': senderName,
          'text': text.trim(),
          'createdAt': now,
          'type': 'system',
        });
      }
      await batch.commit();
    } catch (e, st) {
      debugPrint('[GroupService] broadcastSystemMessage error: $e\n$st');
    }
  }
}


